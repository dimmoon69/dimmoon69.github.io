## <font color="red">Функциональное выражение (function expression)</font>
В JavaScript есть возможность назначить функцию переменной или константе:

```js
const myFunc = function(a,b){
  return a+b;
}; 

console.log(myFunc(3,7));//10
```

<font color="red">*Основное отличие функционального выражения от function declaration(обычной функции) в том, что function declaration создаются интерпретатором до выполнения кода.</font> Это значит, что в момент интерпретации они уже доступны из памяти, а значит такую функцию можно вызвать раньше её объявления в коде. Проиллюстрирую на примере:

```js
console.log(myF(1,4));//5

function myF(a,b){
  return a+b;
}


console.log(myFunc(3,7));//Ошибка!

const myFunc = function(a,b){
  return a+b;
}; 
```

Разумеется function expression вы можете переопределять, назначая переменной другую функцию, либо на ходу выбирать и присваивать переменной одну из реализаций функции:

```js
let age = 18;

let confirmUser = age>=18 ?
  function() {console.log('вход разрешен');} :
  function() {console.log('вход запрещен');}

confirmUser(age);//вход разрешен
```

Сейчас это выглядит не совсем оправдано, и мы могли воспользоваться условием внутри обычной функции, но если каждая реализация достаточно объёмная и ресурсозатратная, это сэкономило бы нам память и скорее всего выглядело бы более компактно и понятно.

#### Именованные функциональные выражения (named function expression):
Как вы, наверное, уже поняли из названия, это те же функциональные выражения, только в этом случае функция имеет имя, это сделано для того, чтобы функция могла как-то обратиться к самой себе, в рекурсивных алгоритмах, например:

```js
//Функция, иллюстрирующая сколько раз нужно вычесть -1, чтобы получить 10
var func = function minus(a){
   if(a>10){
    minus(--a);
    console.log('-1');
  }
}

func(12);
//-1
//-1
```

#### Cтрелочные функции (arrow function) ES6:

Сразу же разберемся на примере с таких функций:

```js
let f1 = () => console.log('Hello');
f1();//Hello

let f2 = name => console.log('Hello, '+name);
f2('User');//Hello, User

let f3 = (a,b) => {
  let res = a*b;
  return res;
}

let a = f3(2,3);
console.log(a);//6
```

Стрелочные функции, как и другие, поддерживают spread-оператор `...` и значения параметров по умолчанию, об этом было рассказано в прошлом шаге.

<font color="red">*Важное отличие стрелочных функций</font> в том, что у них нет собственного контекста `this`

Легче всего это понять на примере с объектом, например, мы хотим написать какие-то методы для него. Как мы знаем из уроков по объектам, чтобы внутри функции ссылаться на него, нужно использовать `this`

```js
let obj = {
  name:'Some object',
  display: function(){
    console.log(this.name);
  },
  print: () => {console.log(this.name);}
}

obj.display();//Some object

obj.print();//Выведет не то что мы ожидаем
```

`this` внутри этой стрелочной функций ссылается на глобальный объект, для браузера это `window`(с ним разберемся позже).

Контекст `this` "вычисляется" для нее в точке вызова, а не в точке объявления как для display в этом случае.

Немного перепишем код выше, пусть в консоль выводится просто this и вот какой результат это даст в браузерной консоли: